# A* Path Finding Algorithm
&nbsp;

## 어떤 원리일까?

자바스크립트로 A* 알고리즘을 시각화 해보고 싶어졌습니다.  
예전부터 공부해왔긴 하지만 완벽하기 이해하고 있지 못했기도 하고 Console 에만 경로를 찍어보는게 싫어 이번에 구현 겸 정리해보기로 하였습니다.

A* 는 블로그와 유튜브에 수많은 강좌가 있지만 대부분 하나의 잘 정리된 곳의 복제였고 그것만으로는 실제로 구현에 들어가기까지 이해하기는 힘들었습니다.  


## 경로 채점 (Path Scoring)
다음에 이동할 노드를 구하는 공식은 아래와 같습니다.

```F = G + H```

* F: 현재까지 이동하는데 걸린비용과 예상비용을 합친 총비용
* G: 시작노드로 부터 현재 노드까지의 경로를 따라 이동하는데 소모되는 비용
* H (Heuristic): 현재 노드에서 목적노드까지의 예상비용. (현재노드와 목적지까지의 장애물의 유무를 현재상태에서는 판단하기 어려우므로 단순 최소비용을 구한다)

이렇게 구해진 주변 노드 중 F Cost 가 가장 작은것이 다음에 이동할 노드입니다.  
F Cost 가 동일한 경우에는 어떻게 하냐구요?  그건 구현자 마음대로 하나의 기준을 정하시면 됩니다.  
동일한 F Cost 가 있다면 오른쪽으로 또는 위로 먼저 이동... 이라던지요...  

## 맵 초기화
제가 구현한 길찾기는 2차원 좌표상에서의 이동이므로 2차원 배열로 표현될 수 있습니다.  
배열의 각 항목은 정하기 나름이겠지만 파악하기 쉬운 값을 대입해 주면 됩니다.  
저의 경우는...  
* w (Wall): 벽
* S (Start): 시작노드
* E (End): 목표노드
* 0: 이동가능한 노드
이렇게 정해주었습니다.  

```
[
  [0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0],
  [0, 's', 0, 0, 0, 'w', 0, 0, 0, 0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  ['w', 'w', 'w', 'w', 0, 'w', 0, 0, 0, 0, 0, 0, 0, 0, 'w', 'w', 'w', 'w', 'w', 'w'],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 'w', 'w', 'w', 0, 'w', 'w', 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 'w', 'w', 'w', 0, 'w', 'w', 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  ['w', 'w', 'w', 'w', 'w', 'w', 0, 0, 0, 0, 0, 0, 0, 0, 'w', 0, 'w', 'w', 'w', 'w'],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0, 0, 0, 0, 'w', 0, 0, 0, 0, 0]
]
```
저는 이런식으로 지형을 표현해 주었습니다.

![width=700px](http://static.devnology.co.kr/files/posts/astar/map_20X20.png)

## 경로 찾기

### 1) 시작노드에서 주변 노드를 모두 검색 (F, G, H 값을 산출)

이 이미지는 A* 를 구현하기 위해 조금이라도 검색을 해보셨다면 정말 지겹도록 봐오셨던 예시일거에요. ㅎㅎㅎ  
하지만 간단한게 경로 찾기 및 벽 회피에 대해 설명하기엔 최적의 구성이기 때문에 그만큼 많이 쓰이는 Map 형태이겠죠.  

![width=500px](http://static.devnology.co.kr/files/posts/astar/map1.png)

제일 처음 할 것은 현재노드(지금은 시작노드) 를 Opened List 에 담는 것입니다.  
이 리스트는 목표 노드에 도달했을 때 최종적인 Path 를 구하기 위해 사용됩니다.  
(노드는 링크드 리스트로 구현하여 각각 Parent 노드를 가지고 있습니다.  
목표 노드에서 시작노드까지 타고 올라가면 최종적인 Path 가 나오게 됩니다.)  

주변노드의 G Cost 는 대각선을 허용하는지 여부에 따라 4방향 또는 8방향으로 선택할 수 있습니다.  
노드와 노드를 이동할때의 거리는 원하는 단위를 정할 수 있지만 계산의 편의성을 위해 1 또는 10으로 하는 것이 좋습니다. (저는 10으로 정했습니다.)  
대각선을 허용한다면 대각선으로의 이동거리는 1.4 또는 14가 됩니다.  
(피타고라스의 정리: a^2 + b^2 = c^2)  
정확히계산하면 대각선의 이동거리는 14.1421.... 이 되겠지만 정수로 계산하는것이 더 편리하고 성능에도 좋으므로 14로 대략적으로 정합니다.  
당연한 소리겠지만 검색중 Wall 이나 Map 의 바깥지역은 검색대상에 넣지 않습니다.  

H Cost 를 구하는 방법은 여러가지가 있습니다. (Manhattan, Heuristic, Pythagoras ...)  
저는 맨하탄 공식을 사용했습니다.  
맨하탄 공식은 택시거리라고도 하는 알고리즘을 사용하는데 이는 2차원 평면좌표계에서 출발지부터 목표까지의 최단거리를 정하는 공식입니다.  

```두 좌표가 (x1, y1), (x2, y2) 일 때, |x1 - x2| + |y1 - y2|```

[택시기하학](https://terms.naver.com/entry.naver?docId=3567439&cid=58944&categoryId=58970)

> 택시거리라는 알고리즘 명도 그렇고 구하는 공식도 그렇고 맨하탄이라는 잘 정리된 계획도시에서 택시가 출발지에서 목적지까지 가는 최단거리가 해당 공식과 같기에 명명되어진 것이 아닐까 생각해봅니다.

여기서 검색된 주변노드들은 모두 Opened List 에 담습니다.  
Opened List 진행방향이 될 가능성이 있는 리스트로서 Wall 이나 이미 지나온 노드들은 담기지 않을 것이고, 대각선을 허용한다면 최대 8개, 허용하지 않는다면 최대 4개가 담기게 되겠죠.

그리고 Opened List 를 F Cost 를 기준으로 오름차순으로 정렬해 줍니다.  
이제 Opened List 의 가장 윗 항목이 다음에 이동할 노드입니다.

> 사실 이 부분은 좋은 로직은 아닙니다.  
> 단순히 Opened List 를 정렬하여 F Cost 최소값을 다음 노드로 정하게 된다면 탐색해야 하는 범위가 2배 이상으로 늘어나게 됩니다.  
> 저도 아직 방향성에 대한 이론이 확립되지 않아 이런식으로 구현하긴 했지만 다음 버전에 개선해야 하는 첫번째 과제입니다.
### 2) F 값이 제일 작은 노드를 찾음

1)에서 주변노드들을 탐색하여 Opened List 에 담아주셨을 겁니다. 이를 오름차순으로 정렬하여 F Cost 가 가장 작은 노드가 제일 위에 위치하고 있겠죠.  

이제 가장 위 노드를 꺼내어 Closed List 에 담고 이 노드를 기준으로 주변 노드를 재 탐색하여 줍니다.  

Closed List 는 이미 지나온 길이기 때문에 주변 노드 검색 시 검색 대상에 넣지 않습니다.  
(다시 갈 일이 없다는 얘기죠)  


### 3) F Cost 가 가장 작은 노드로 이동
현재 위치를 이동하면서 각 노드의 주변을 탐색한 후 Opened List 에 담아주셨을 겁니다.  
이 Opened List 를 Loop 를 돌면서 F Cost 가 가장 작은 노드가 다음 노드가 됩니다.  

![width=500px](http://static.devnology.co.kr/files/posts/astar/neighbor_search_1.png)
이런식으로 현재노드의 주변을 모두 탐색하여 F Cost 를 구해준 뒤 최소 F 값을 찾아 이동하면 됩니다.  
그리고 이동한 노드의 주변을 다시 검색해주고 최소 F Cost 를 찾아 이동 및 반복.  

제 방법은 이미 언급했지만 구현은 간단하지만 방향성이 없기 때문에 F Cost 가 작은 값을 모두 방문하게 됩니다. 주변노드도 다시 재계산해주어야 겠지요...  
검색경로를 디버깅해보면 목표와는 전혀 반대의 방향으로 탐색하는 경우를 보게됩니다.  
그래서 사실 최적의 성능을 보장해주는 로직은 아닙니다.  
하지만 이동하다가 더이상 이동할 곳이 없을때의 케이스를 신경쓰지 않아도 된다는 점때문에 간단하게 구현할 수 있습니다.  
(사실 이 경우를 제대로 설명해주는 곳이 없어 이렇게 구현한 것도 있습니다.)  

### 4) 목표 노드에 도달하면 프로세스를 종료
이렇게 1), 2), 3) 을 반복하다가 주변 노드 검색 중 골을 발견한다면 Loop 를 종료합니다.  
목표 노드에서 부터 Parent 를 타고 올라가면 최종 Path 가 나오게 됩니다.  

## 구현
아래는 나무위키에서 가져온 Pseudo 코드입니다. 제가 작성한 코드도 이 로직을 많이 참고했습니다.  
[나무위키 - A* 알고리즘](https://namu.wiki/w/A*%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

```
PQ.push(start_node, g(start_node) + h(start_node)) // 우선순위 큐에 시작 노드를 삽입한다.

while PQ is not empty // 우선순위 큐가 비어있지 않은 동안
    node = PQ.pop // 우선순위 큐를 pop한다.

    if node == goal_node // 만일 해당 노드가 목표 노드이면 반복문을 빠져나온다.
        break

    for next_node in (next_node_begin...next_node_end) // 해당 노드에서 이동할 수 있는 다음 노드들을 보는 동안
        PQ.push(next_node, g(node) + cost + h(next_node)) // 우선순위 큐에 다음 노드를 삽입한다.

print goal_node_dist
```

제가 구현한 코드는 아래에서 확인하실 수 있습니다.  
[Astar-JS in GitLab](https://github.com/cheonsoo/astar-js)

## 데모
[A* 데모 보기](/apps/astar)

![Image](http://static.devnology.co.kr/files/posts/astar/astar_sample_1.png)


## 마치며

저도 예전에 작성한 코드와 기억을 더듬어 작성한 포스트이다보니 이론상 오류도 있을 수 있고 코드도 비효율적입니다... ㅠㅠ  
그래도 어느정도는 이해하는데 도움이 되었으면 합니다.  
저도 포스트 하나만으로 이해하지는 못했고 여러 포스트들과 Youtube 동영상을 본뒤에야 대략적으로나마 이해할 수가 있었습니다.  
실제로 구현에 들어가기 까지는 더 오랜시간이 걸렸던 것 같아요. 사실 지금와서는 기본 원리는 크게 어려운 것은 아니었는데 중간중간 생기는 궁금증을 해소시켜주는 곳이 없어 어려웠던 것 같아요.  
예를 들면  
* 진행을 반복하다가 더 이상 나아갈 곳이 없을 때의 케이스는 어떻게 처리할 것인가?
* F Cost 의 재계산(Re-caculating) 은 언제, 어떻게 할 것인가?


## 레퍼런스
[A* Path Finding Animation](https://adrianstoll.com/a-star-pathfinding/)  
